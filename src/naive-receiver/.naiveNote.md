# About protocol
A pool with 1000WETH in balance offering flashloans with a fixedFee of 1 WETH. 
Support meta-transactions by intergrating permissionless forwarder contract. 

User with a 10 WETH contract in balance can execute flashloans of WETH. 

All funds are at risk, rescue all WETH from the user and the pool and deposit to a recovery account. 
    Exploit the user
    Exploit the flashloan 
    recover the amount and send the funds to a designated account



## Understanding main contract
deposit mapping since this is a pool managing payable _weth, to give out loans. 

**Entry point:flashLoan**
- Check, if you are not taking a flashloan of weth, then the currency is unsupported. 
- Do a transfer and later deduct the anount from all deposits. This step is open to reentrancy. 
- Check callback. Function onFlashLoan of the FlashBorrower is always constant naming relative to the ERC3156 standard.
- amountWithFee is later amount + Fee. This done a lot later, however the call back is not checking for amount+fee. 
- weth being declared payable at the top, we can call it directly with referencing payable(weth). transferFrom receiver to this address amountNFee
- Update the totalDeposit and allocate the fee collected to the feeReceiver deposits. 

*Issues*
- We are not checking the balance of the pool before handing out the loans. 
- There is a reentrancy opportunity below
    ```
        weth.transfer(address(receiver), amount);
        totalDeposits -= amount;
        //Total deposit is updated after transfer
    ```
**withdraw(amount, payable receiver)**
- There is no handle of the revert incase _msgSender() doesn't exist. 
- deduct the amount to withdraw from both deposit mapping and totalDeposit. 
- weth.transfer to send the amount from the contract pool to the owner's access. 

## Basic Forwarder
**Entry point: execute()**
- Check execute request for 5 issues. There is no expected return value, it will either pass or revert. 
- Add the nonce
- assign value and target from the request. 
- assign payload -> concat data and from
- Pass the data in assembly code 
    add 
    mload
    gas()

### What is the difference between abstract and interface?
    Abstract is used when you want to generalize behaviour and 
        In an abstract, we intended to compliment many parents and inherit from them.
    Interface is used when you want standardize behaviour. 
        In Interface we intend to maintain and not break a standard and or behaviour. This means you need to implement all the methods mentioned in it.
        Interfaces provide a default behaviour inorder to ensure that you compile code. 

### What are meta-transactions?
    Meta-transactions are a pattern that allows users to interact with a smart contract without paying gas themselves.
    Instead, someone else (a relayer or sponsor) submits the transaction on-chain, paying the gas fee on behalf of the user.

    This enables gasless UX similar to Web2 apps.


### Openzeppelin library: Address
- This is a collection of functions related to the address type. -> sendValue, functionCall, functionDelegateCall etc. 

    Answer: functionDelegateCall

# Solution
- The multicall ensures we run all the calls in tandem. A total of 11 calls
- A user has 10 WETH and we have to recover it
    The FlashLoanReciever doesn't specify who calls for the loan. So with that we shall call the contract to take a loan and pay the fee to the recovery account. 
    ```
       for (uint i = 0; i < 10; i++) {
            callDatas[i] = abi.encodeCall(
                NaiveReceiverPool.flashLoan,
                (receiver, address(weth), 1, "0x")
            );
        }
    ```
    In the code above, we are taking a loan using the users contract. The loan we are taking is 1WETH so we can pay the fixed fee 10 times
- Recover the amount in the pool to empty the pool is what need to be understood since it is relatively complex. 
    1. Because we are packing everything into an array of byte data. The 11th call is made to empty the pool into the recovery account. 
    2. EncodePacked(the 11th call). 
        This references the withdraw(there's only two ways to empty the pool flashLoan and this). And because this is access controlled, we need the contract owner as well i.e. You can only withdraw what is mapped to you. 
    3. Prepare the call for a multiCall. To be passed into multicall. 
        This is `pool.muliticall` because the pool inherits multicall. 
    4. Declare the request. This is so that we can modify the call to be able to withdraw the contract
        In the basicForwarder contract we have the request struct that we need to be build. 
    5. Hash the request and prepare a signature
        The request to execute, we need a request and signature
        Using a player(depositor) private key, sign the requestHash created. 
    6. Execute the transaction using the trusted forwarder. 






    First we pack the last call that is supposed to withdraw the amount. 
    Employed encodeCall() - takes in the functionand it's relevant args.
    Encodepacked with the deployer address as bytes 32
    Output ya encode call ni bytes. 



