# The protocol

Flashloan pool with 1 million DVT

Challenge

- Rescue all funds in the pool executing a single transaction.
- Deposit rescued funds to a recovery account

## Logic

- Check the balance of the pool contract.
- transfer amount to borrower
- target.functionCall(data)

**functionCall** [https://search.brave.com/search?q=target.functionCall%28%29+solidity+and+blockchain+function&source=web&summary=1&conversation=08ad2254c113888036286d986fa55c51e34f]

In solidiry is a safe, high-level function provided by OpenZeppelin's `Address` library to call functions on other contracts. Safer alternative to the raw call.
Purpose

- Enable contract to call a function on a target contract with specified data, while handling reverts and edge cases.
  targe.functionCall(data)
  Key features
- Error handling; reverts with a `FailedCall` error
- Ensures the target address is a contract
- Returns the raw bytes returned by the target function.

This is what the function call does

```javascript
  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
      if (address(this).balance < value) {
          revert Errors.InsufficientBalance(address(this).balance, value);
      }
      (bool success, bytes memory returndata) = target.call{value: value}(data);
      return verifyCallResultFromTarget(target, success, returndata);
```

## The hack

> @ The function `target.functionCall(data);`is an open external low-level call.
> The way it is set up from the address contract, the function is parsing the data.

- With the above function we can parse arbitrary data into the contract.
- With ERC20 tokens we have the approval where you can approve another contract to spend the tokens on your behalf.

- With the above thought process, we can encode the approve logic into the data to approve our contract to spend the pool's money.
- This creates a backdoor into the pool and not emptying out the contract.
- We can therefore use transfer after the fact.

- Understanding the contract standards can therefore give you leeway to attack contracts.
- There's alot of type casting the data even if it is already type safe.
  This is because we initially type casted it (pool) as TrusterLenderPool.

- On deployment the contract automatically executes the code in constructor.

- encodeWithSignature()
  - Function Signature: The first argument is a string representing the function name and parameter types (e.g., "transfer(address,uint256)").
  - Arguments: The remaining arguments are the actual values passed to the function.
  - Output: Returns a bytes memory array that combines the function selector (first 4 bytes of the keccak256 hash of the signature) and the ABI-encoded arguments.

``` javascript
  function callTransfer(address token, address to, uint256 amount) public {
    bytes memory data = abi.encodeWithSignature("transfer(address,uint256)", to, amount);
    (bool success, ) = token.call(data);
    require(success, "Transfer failed");
  }
  ```

When to Use:
  - Low-level interactions with external contracts (e.g., when using .call()).
  - Dynamic function calls where the function name or parameters are determined at runtime.
  - Interacting with contracts without knowing their ABI at compile time.
Important Notes:
  - Use uint256, not uint, to ensure correct function selector generation.
  - Avoid spaces in the function signature string (e.g., "add(uint,uint)" is correct, "add( uint, uint )" is not).
  - For functions with no arguments, use "functionName()" (e.g., "initialize()").
Comparison with Alternatives:
  - `abi.encodeWithSelector`: Uses a precomputed 4-byte function selector instead of a string signature. More efficient when the selector is known.
  - `abi.encode`: Encodes only raw data, not function signatures. Use for encoding arbitrary data, not function calls.
  - `abi.encodePacked`: Minimizes encoded size by removing padding. Not suitable for function calls, as it breaks ABI rules.
