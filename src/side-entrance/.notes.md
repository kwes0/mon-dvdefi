# The application 
Allow anyone to deposit and withdraw at anytime.

The contract has 1000 ETH in balance already and offering flashloans using the deposited ETH.

Starting with 1 ETH in balance. Pass the challenge by rescuing all ETH from the pool and depositing it in the designated recovery account. 

## Application logic 
1. deposit()
  - Deposit a balance to the pool. This is unchecked()
2. withdraw()
  - withdraw your mapped balance
3. flashLoan(amount)
  - Using an interface execute the flashloan and if the amount received back is less than the initial balance before transaction, revert the whole thing. 

  `IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();`
  - `msg.sender` refers to the address that called the flashLoan function, which must be a contract(Not an EOA) because it needs to implement the IFlashLoanEtherReceiver interface
  - execute{value: amount}() invokes the execute function on the msg.sender contract sending amount ETH to it as part of the call. 

flashLoan(amount){
  This is implements the interfaceFlashLoanEthReceiver on the msg.sender, executing the the function in the msg.sender contract. 

  The one who calls this function needs to implement the function. 
  In the execute, they need to execute the payback otherwise the check to revert is true.  
}
  


## Challenge
Empty out the contract to a recovery account. 
What are the ways to empty out a contract??
  - withdraw
  - flashLoan

How do we get the money out?
  - We can write a contract to execute a loan of the balanceOf(this) and through this contract in the same breathe deposit the loan into the contract and then withdraw it. 

## The hack
- Vulnerability = flashloan + deposit.
- flashLoan you request whatever amount you want and deposit it back into the contract to have the balance of the contract still greater than what was there before since you have the 1 ETH to start. 
- execute is a public and payable function
  When the flashLoan() calls your execute() function, it sends ETH along with that call. To receive and use that ETH value, your function needs the payable keyword. Without it, Solidity won't let you access msg.value because the function can't accept ETH.


**unchecked()**
The unchecked keyword in Solidity is used to disable overflow and underflow checks for arithmetic operations within a specific block, allowing them to wrap around silently instead of reverting. 
  - gas optimization because safety checks are conducted in default arithmetic checks
Scope -> unchecked block only applies to statements inside it. 

When to use
  - Loop counters where bounds are already checked
  - Known-safe arithmetic
  - Performance-critical code where gas savings are significant


